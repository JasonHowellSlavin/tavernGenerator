{"version":3,"sources":["modules/utility.js","App.js","serviceWorker.js","index.js"],"names":["randomChoice","length","Math","ceil","random","App","props","state","title","spreadsheetID","tavernUrl","bartendersUrl","tavernData","bartenderDataClean","tavernDataClean","tavernSize","currentTavern","currentBartender","handleTavernSizeSelect","bind","generateData","handleTavernSelect","data","objectKeys","forEach","item","splitKey","$t","split","parseInt","content","keyLength","Object","keys","finalForm","captureObject","index","itemType","push","console","log","event","target","value","this","setState","size","slice","bartenderData","selectedSizeTavern","filter","tavern","toLowerCase","selectedSizeBartender","bartender","selectedTavern","selectedBartender","a","fetch","then","response","json","data2","feed","entry","className","onChange","onClick","name","atmosphere","appearance","greeting","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.4db5a4e5.chunk.js","sourcesContent":["export const randomChoice = function (length) {\n  return Math.ceil(Math.random() * length);\n};","import React, { Component } from 'react';\nimport './App.scss';\nimport { randomChoice } from \"./modules/utility\";\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      title: 'Tavern Generator',\n      spreadsheetID: '1mtVEMzpXl2epoFvwv25vsbVdV4NaN6ASFU1CrSMxq5o',\n      tavernUrl: `https://spreadsheets.google.com/feeds/cells/1mtVEMzpXl2epoFvwv25vsbVdV4NaN6ASFU1CrSMxq5o/1/public/full?alt=json`,\n      bartendersUrl: `https://spreadsheets.google.com/feeds/cells/1mtVEMzpXl2epoFvwv25vsbVdV4NaN6ASFU1CrSMxq5o/2/public/full?alt=json`,\n      tavernData: [],\n      bartenderDataClean: [],\n      tavernDataClean: [],\n      tavernSize: '----',\n      currentTavern: {},\n      currentBartender: {},\n    };\n    this.handleTavernSizeSelect = this.handleTavernSizeSelect.bind(this);\n    this.generateData =  this.generateData.bind(this);\n    this.handleTavernSelect = this.handleTavernSelect.bind(this);\n  }\n\n  generateData(data) {\n    let objectKeys = {};\n\n    data.forEach((item) => {\n      let splitKey = item.title.$t.split('');\n\n      if (parseInt(splitKey[1]) === 1) {\n        objectKeys[splitKey[0]] = item.content.$t;\n      }\n    });\n\n    let keyLength = Object.keys(objectKeys).length;\n    let finalForm = [];\n    let captureObject = {};\n\n    for (let index = keyLength; index < data.length; index++) {\n      let itemType = data[index].title.$t.split('')[0]; // Returns A, B, C, etc.\n\n      captureObject[objectKeys[itemType]] = data[index].content.$t;\n\n      if (Object.keys(captureObject).length === keyLength) {\n        finalForm.push(captureObject);\n        captureObject = {};\n      }\n    }\n\n    console.log(objectKeys);\n    console.log('final form', finalForm);\n\n    return finalForm\n  }\n\n  handleTavernSizeSelect(event) {\n    console.log(event.target.value, this.state.tavernSize);\n\n    this.setState({tavernSize: event.target.value});\n  }\n\n  handleTavernSelect() {\n    let size = this.state.tavernSize;\n    let tavernData = this.state.tavernDataClean.slice();\n    let bartenderData = this.state.bartenderDataClean.slice();\n    let selectedSizeTavern = tavernData.filter((tavern) => tavern.size.toLowerCase() === size);\n    let selectedSizeBartender = bartenderData.filter((bartender) => bartender.size.toLowerCase() === size);\n    let selectedTavern = selectedSizeTavern[randomChoice(selectedSizeTavern.length) - 1];\n    let selectedBartender = selectedSizeBartender[randomChoice(selectedSizeBartender.length) - 1];\n\n    this.setState({currentTavern: selectedTavern, currentBartender: selectedBartender});\n  }\n\n  componentDidMount() {\n    (async () => {\n      const data = await fetch(this.state.tavernUrl).then((response) => {return response.json()});\n      const data2 = await fetch(this.state.bartendersUrl).then((response) => {return response.json()});\n\n      console.log(data.feed, data2.feed);\n\n      this.generateData(data.feed.entry);\n      this.generateData(data2.feed.entry);\n\n      this.setState({\n        tavernData : data.feed.entry,\n        tavernDataClean: this.generateData(data.feed.entry),\n        bartenderDataClean: this.generateData(data2.feed.entry),\n      });\n    })()\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <div>\n            <p>{this.state.title}</p>\n            <p>Select your tavern size:</p>\n            <select value={this.state.tavernSize} onChange={this.handleTavernSizeSelect}>\n              <option value='----'> ---- </option>\n              <option value='small'>Small</option>\n              <option value='medium'>Medium</option>\n            </select>\n            <button onClick={() => {if (this.state.tavernSize !== '----') this.handleTavernSelect()}}>Go to the Tavern!</button>\n          </div>\n          {Object.keys(this.state.currentTavern).length > 0 && <div>\n            <p>You walk into a tavern called <span className={'highlighted'}>{this.state.currentTavern.name}</span>.</p>\n            <p><span className={'highlighted'}>{this.state.currentTavern.atmosphere}</span>.</p>\n            <p>You walk up to the bar, behind which stands <span className={'highlighted'}>{this.state.currentBartender.name}</span>, <span className={'highlighted'}>{this.state.currentBartender.appearance}</span>.</p>\n            <p><span className={'highlighted'}>{this.state.currentBartender.greeting}</span>.</p>\n          </div>}\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}